<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>web前端知识点高级集锦</title>
    <link rel="stylesheet" type="text/css" href="webHQA.css">
</head>
<body>
<div class="container">
    <div><h2>web前端知识点高级集锦</h2></div>
    <ul>
        <li>
            <dt>1.JavaScript作用域和作用域链</dt>
            <dd>
                <p>任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p>
                <p>1.最外层函数和在最外层函数外面定义的变量拥有全局作用域，</p>
                <p>2.所有末定义直接赋值的变量自动声明为拥有全局作用域，</p>
                <p>3.所有window对象的属性拥有全局作用域。</p>
                <p>一般情况下，window对象的内置属性都拥有全局作用域。和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域。</p>
                <p>在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
            </dd>
        </li>
        <li>
            <dt>2.JavaScript变量声明提升</dt>
            <dd>
                <p>javascript的变量声明具有hoisting机制，JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面。javascript是没有块级作用域的。函数是JavaScript中唯一拥有自身作用域的结构。javascript中一个名字(name)以四种方式进入作用域(scope)，其优先级顺序如下</p>
                <p>1、语言内置：所有的作用域中都有 this 和 arguments 关键字</p>
                <p>2、形式参数：函数的参数在函数作用域中都是有效的</p>
                <p>3、函数声明：形如function foo() {}</p>
                <p>4、变量声明：形如var bar;</p>
            </dd>
        </li>
        <li>
            <dt>3.JavaScript原型链</dt>
            <dd>
                <p>每个对象都会在其内部初始化一个属性，就是__proto__，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去__proto__里找这个属性，这个__proto__又会有自己的__proto__，于是就这样一直找下去，也就是我们平时所说的原型链的概念。其实prototype只是一个假象，他在实现原型链中只是起到了一个辅助作用，换句话说，他只是在new的时候有着一定的价值，而原型链的本质，其实在于__proto__。</p>
            </dd>
        </li>
        <li>
            <dt>4.JavaScript数组元素去重的方法</dt>
            <dd>
                <p>一，常规方法：</p>
                <p>1.构建一个新的数组存放结果</p>
                <p>2.for循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比</p>
                <p>3.若结果数组中没有该元素，则存到结果数组中</p>
                <p>如何解决回调层级过深的问题</p>
                <p>Ajax跨域的几种方法以及每种方法的原理，比如Jsonp的原理，使用window.name属性通过递延来跨域的缺点</p>
                <p>二，先排序再存放元素：</p>
                <p>1.先将原数组进行排序</p>
                <p>2.检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，因为已经排序，所以重复元素会在相邻位置</p>
                <p>3.如果不相同，则将该元素存入结果数组中</p>
                <p>三，对象属性比较：</p>
                <p>1.创建一个新的数组存放结果</p>
                <p>2.创建一个空对象</p>
                <p>3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。</p>
                <p>说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。</p>
            </dd>
        </li>
        <li>
            <dt>5.Zepto框架与jquery的比较</dt>
            <dd>
                <p>1、Zepto是为现代智能手机浏览器推出的Javascript 框架, 有和jQuery相似的语法, 和jQuery相比下来, 他有很多优点, 大小方面 , 压缩后的 zepto.min.js 大小只有21K, 使用服务器端 gzip 压缩后大小只有5~10K, 可以说非常的小, 功能很齐全, 多出来了一些触摸屏的事件,它对PC的浏览器就不是那么理想,尤其是万恶IE直接过滤不兼容, 用它来开发手机iPhone和Android网页是不错的选择。</p>
                <p>2、jquery主要是用在PC的网页中了，jquery是目前最流行的javascript框架，以其兼容全部主流浏览器，插件丰富，代码简洁，最关键的是更新快，最好的dom选择器而被广泛被使用。而手机wap方面的话，jquery也推出jquery-mobile，也很好用。</p>
            </dd>
        </li>
        <li>
            <dt>6.body中的onload()函数和jQuery中的document.ready()有什么区别？</dt>
            <dd>
                <p>onload()和document.ready()的区别有以下两点：</p>
                <p>1、我们可以在页面中使用多个document.ready()，但只能使用一次onload()。</p>
                <p>2、document.ready()函数在页面DOM元素加载完以后就会被调用，而onload()函数则要在所有的关联资源（包括图像、音频）加载完毕后才会调用。</p>
            </dd>
        </li>
        <li>
            <dt>7.jQuery中有哪几种类型的选择器？</dt>
            <dd>
                <p>1、基本选择器：直接根据id、css类名、元素名返回匹配的dom元素。</p>
                <p>2、层次选择器：也叫做路径选择器，可以根据路径层次来选择相应的DOM元素。</p>
                <p>3、过滤选择器：在前面的基础上过滤相关条件，得到匹配的dom元素。</p>
            </dd>
        </li>
        <li>
            <dt>8.当CDN上的jQuery文件不可用时，该怎么办？</dt>
            <dd>
                <p>为了节省带宽和脚本引用的稳定性，我们会使用CDN上的jQuery文件，例如google的jquery cdn服务。但是如果这些CDN上的jQuery服务不可用，我们还可以通过代码来切换到本地服务器的jQuery版本。</p>
            </dd>
        </li>
        <li>
            <dt>9.web前端页面如何优化</dt>
            <dd>
                <p>一、提倡前端开发工程师在书写xhtml的时候做到结构语义化。实现结构，表现，行为的分离。</p>
                <p>二、css，js文件数量及大小的优化。建议css和js采用外联式。尽量的采用缩写，减少css和js文件的大小，减少http请求数。</p>
                <p>三、背景图片数量及大小的优化。建议使用PNG8格式的图片结合css sprite，同样的图片，PNG8格式会相对来比GIF小。</p>
                <p>作为大型网站来说，首页使用内联式样式表，这样可以减少http请求数的同时，也可以防止裸奔。当然其他页面需要使用外联样式表，这样才可以方便维护。因为作为大型网站来说，他的首页访问量是非常的大的，所以。。</p>
                <p>把样式表置于顶部</p>
                <p>把脚本置于页面底部</p>
                <p>避免使用 CSS 表达式（Expression）</p>
                <p>使用外部 JavaScript 和 CSS</p>
                <p><p>削减 JavaScript 和 CSS</p>
                <p>用 link 代替 @import</p>
                <p>避免使用滤镜</p>
                <p>剔除重复脚本</p>
                <p>减少DOM访问</p>
                <p>开发智能事件处理程序</p>
                <p>最好的方案就是按照 HTML 规范在文档 head  内加载你的样式表。</p>
                <p>对于拥有较大浏览量的首页来说，有一种技术可以平衡内置代码带来的 HTTP 请求减少与通过使用外部文件进行缓存带来的好处。其中一个就是在首页中内置 JavaScript 和 CSS ，但是在页面下载完成后动态下载外部文件，在子页面中使用到这些文件时，它们已经缓存到浏览器了。</p>
            </dd>
        </li>
        <li>
            <dt>10.如何解决重绘和回流的问题</dt>
            <dd>
                <p>1. 直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）</p>
                <p>2. 让要操作的元素进行”离线处理”，处理完后一起更新</p>
                <p>a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；</p>
                <p>b) 使用display:none技术，只引发两次回流和重绘；</p>
                <p>c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；</p>
                <p>3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存</p>
                <p>4. 让元素脱离动画流，减少回流的Render Tree的规模。</p>
                <p>5.尽可能在DOM树的最末端改变class（可限制回流的范围）；</p>
                <p>6.避免设置多层内联样式（将样式合并在一个外部类，仅产生一次回流）；</p>
                <p>7.动画效果应用到position属性为absolute或fixed的元素上（动画效果应用到position属性为absolute或fixed的元素上，它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低。）；</p>
                <p>8.牺牲平滑度换取速度（Opera还建议我们牺牲平滑度换取速度，其意思是指您可能想每次1像素移动一个动画，但是如果此动画及随后的回流使用了 100%的CPU，动画就会看上去是跳动的，因为浏览器正在与更新回流做斗争。动画元素每次移动3像素可能在非常快的机器上看起来平滑度低了，但它不会导 致CPU在较慢的机器和移动设备中抖动。）；</p>
                <p>9.避免使用table数据（在布局完全建立之前，table经常需要多个关口，因为table是个和罕见的可以影响在它们之前已经进入的DOM元素的显示的元素。）；</p>
                <p>10.避免使用css的JavaScript表达式（因为他们每次重新计算文档，或部分文档、回流。正如我们从所有的很多事情看到的：引发回流，它可以每秒产生成千上万次。）</p>
            </dd>
        </li>
        <li>
            <dt>11.什么是JSON？</dt>
            <dd>
                <p>JSON，JavaScript 对象表示法（JavaScript Object Notation），是一种轻量级的数据交换格式。JSON 值可以是：数字（整数或浮点数）,字符串（在双引号中）,逻辑值（true 或 false）,数组（在方括号中）,对象（在花括号中）,null,没有像JavaScript一样的undefined、NAN。JSON一般以字符串的形式在数据交互过程中游走，so对于js而言，如何将json字符串和js对象之间进行相互转换显得尤为重要。</p>
            </dd>
        </li>
        <li>
            <dt>12.常用的Javascript设计模式。</dt>
            <dd>
                <p>一 单例模式</p>
                <p>单例模式的思路是：一个类能返回一个对象的引用（并且永远是同一个）和一个获得该实例的方法（静态方法，通常使用 getInstance 名称）。那么当我们调用这个方法时，如果类持有的引用不为空就返回该引用，否者就创建该类的实例，并且将实例引用赋值给该类保持的那个引用再返回。同时将该类的构造函数定义为私有方法，避免其他函数使用该构造函数来实例化对象，只通过该类的静态方法来得到该类的唯一实例。</p>
                在应用单例模式时，生成单例的类必须保证只有一个实例的存在，很多时候整个系统只需要拥有一个全局对象，才有利于协调系统整体的行为。比如在整个系统的配置文件中，配置数据有一个单例对象进行统一读取和修改，其他对象需要配置数据的时候也统一通过该单例对象来获取配置数据，这样就可以简化复杂环境下的配置管理。</p>
                <p>二 工厂模式</p>
                <p>工厂模式与简单工厂模式的区别在于工厂模式使用子类来创建对象，而不是一个独立的类。工厂模式是软件工程领域一种广为人知的设计模式，而由于在ECMAScript中无法创建类，因此用函数封装以特定接口创建对象。其实现方法非常简单，也就是在函数内创建一个对象，给对象赋予属性及方法再将对象返回即可。工厂模式的实现方法非常简单，解决了创建多个相似对象的问题，但是工厂模式却无从识别对象的类型，因为全部都是Object，不像Date、Array等，因此出现了构造函数模式。</p>
                <p>三 构造函数模式</p>
                <p>ECMAScript中构造函数可以创建特定类型的对象，类似于Array、Date等原生JS的对象。按照惯例，构造函数的首写字母用大写，没有显示的创建对象，直接将属性和方法赋值给了this对象，没有return语句，使用new创建对象，能够识别对象。使用构造函数的最大的问题在于每次创建实例的时候都要重新创建一次方法（理论上每次创建对象的时候对象的属性均不同，而对象的方法是相同的），然而创建两次完全相同的方法是没有必要的，因此，我们可以将函数移到对象外面。</p>
                <p>四 原型模式</p>
                <p>我们创建的每个函数都有prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处就是可以让所有对象实例共享它所包含的属性及方法。原型模式省略了构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得了相同的属性值，这样非常不方便，但这还是不是原型的最大问题，原型模式的最大问题在于共享的本性所导致的，由于共享，因此因此一个实例修改了引用，另一个也随之更改了引用。因此我们通常不单独使用原型，而是结合原型模式与构造函数模式。</p>
                <p>五 混合模式（原型模式 + 构造函数模式）</p>
                <p>混合模式中构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。每个实例都会有自己的一份实例属性，但同时又共享着方法，最大限度的节省了内存。另外这种模式还支持传递初始参数。优点甚多。这种模式在ECMAScript中是使用最广泛、认同度最高的一种创建自定义对象的方法。</p>
                <p>六 动态原型模式</p>
                <p>动态原型模式将所有信息封装在了构造函数中，而通过构造函数中初始化原型（仅第一个对象实例化时初始化原型），这个可以通过判断该方法是否有效而选择是否需要初始化原型。</p>
            </dd>
        </li>
        <li>
            <dt>13.IE6 BUG的解决方法</dt>
            <dd>
                <p>1. 双边距BUG float引起的 使用display</p>
                <p>2. 3像素问题 使用float引起的 使用dislpay:inline -3px</p>
                <p>3. 超链接hover 点击后失效 使用正确的书写顺序 link visited hover active</p>
                <p>4. Ie z-index问题 给父级添加position:relative</p>
                <p>5. Png 透明 使用js代码 改</p>
                <p>6. Min-height 最小高度 !Important 解决’</p>
                <p>7. select 在ie6下遮盖 使用iframe嵌套</p>
                <p>8. 为什么没有办法定义1px左右的宽度容器(IE6默认的行高造成的,使用 over:hidden,zoom:0.08 line-height:1px)</p>
                <p>9. ie 6 不支持!important</p>
            </dd>
        </li>
        <li>
            <dt>14.清除浮动的几种方式,各自的优缺点</dt>
            <dd>
                <p>1.使用空标签清除浮动 clear:both(理论上能清楚任何标签,增加无意义的标签)</p>
                <p>2. 使用overflow:auto(空标签元素清除浮动而不得不增加无意代码的弊端,,使用 zoom:1 用于兼容IE)</p>
                <p>3. 是用afert伪元素清除浮动(用于非IE浏览器)</p>
            </dd>
        </li>
        <li>
            <dt>15.CSS定位方式有哪些?position属性的值有哪些?他们之间的区别是什么?</dt>
            <dd>
                <p>在CSS中关于定位的内容是:position:relative | absolute | static | fixed</p>
                <p>1. static 没有特别的设定,遵循基本的定位规定,不能通过z-index进行层次分级。</p>
                <p>2. relative 不脱离文档流,参考自身静态位置通过 top,bottom,left,right 定位,并且 可以通过z-index进行层次分级。</p>
                <p>3. absolute 脱离文档流,通过 top,bottom,left,right 定位。选53D6其最近的父级定 位元素,当父级 position 为 static 时,absolute元素将以body坐标原点进行定位, 可以通过z-index进行层次分级。</p>
                <p>4. fixed 固定定位,这里他所固定的对像是可视窗口而并非是body或是父级元素。可 通过z-index进行层次分级。</p>
            </dd>
        </li>
        <li>
            <dt>16.异步ajax的优缺点都有什么?</dt>
            <dd>
                <p>优点:
                <p>a. 相对于同步ajax:不会造成UI卡死,用户体验好。</p>
                <p>b. 相对于刷新页面,省流量。</p>
                <p>缺点:</p>
                <p>a. 后退按钮无效。</p>
                <p>b. 多个请求同时触发时,由于回调时间不确定,会造成混乱,避免这种混乱需要复杂的 判断机制。</p>
                <p>c. 搜索引擎不友好。</p>
                <p>d. 数据安全。</p>
            </dd>
        </li>
        <li>
            <dt>17.对Node的优点和缺点提出了自己的看法?</dt>
            <dd>
                <p>1. 优点:因为Node是基于事件驱动和无阻塞的,所以非常适合处理并发请求, 因此 构建在Node上的代理服务器相比其他技术实现(如Ruby)的服务器表现要好得 多。 此外,与Node代理服务器交互的客户端代码是由javascript语言编写的, 因 此客户端和服务器端都用同一种语言编写,这是非常美妙的事情。</p>
                <p>2. 缺点:Node是一个相对新的开源项目,所以不太稳定,它总是一直在变, 而且缺 少足够多的第三方库支持。看起来,就像是Ruby/Rails当年的样子。</p>
            </dd>
        </li>
        <li>
            <dt>18.对语义化如何理解?</dt>
            <dd>
                <p>
                    用正确的标签做正确的事情! HTML语义化就是让页面的内容结构化,便于对浏览器、搜索引擎解析;在没有样式CCS 情况下也以一种文档格式显示,并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定 上下文和各个关键字的权重,利于 SEO。使阅读源代码的人对网站更容易将网站分块, 便于阅读维护理解。
                </p>
            </dd>
        </li>
        <li>
            <dt>19.http状态码有那些?分别代表是什么意思?</dt>
            <dd>
                <p>100-199 用于指定客户端应相应的某些动作。</p>
                <p>200-299 用于表示请求成功。</p>
                <p>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。</p>
                <p>400- 499 用于指出客户端的错误。</p>
                <p>400 语义有误,当前请求无法被服务器理解。</p>
                <p>401 当前请求需要用户验证</p>
                <p>403 服务器已经理解请求,但是拒绝执行它。</p>
                <p>500-599 用于支持服务器错误。</p>
                <p>503 – 服务不可用</p>
            </dd>
        </li>
        <li>
            <dt>20.对前端界面工程师这个职位是怎么样理解的?它的前景会怎么样?</dt>
            <dd>
                <p>前端是最贴近用户的程序员,比后端、数据库、产品经理、运营、安全都近。</p>
                <p>1. 实现界面交互</p>
                <p>2. 提升用户体验</p>
                <p>3. 有了Node.js,前端可以实现服务端的一些事情</p>
                <p>前端是最贴近用户的程序员,前端的 能力就是能让产品从 90分进化到 100 分,甚至更好, 参与项目,快速高质量完成 实现效果图,精确到1px; 与团队成员,UI设计,产品经理的沟通; 做好的页面结 构,页面重构和用户体验; 处理hack,兼容、写出优美的代码格式; 针对服务器 的优化、拥抱最新前端技术。</p>
            </dd>
        </li>
        <li>
            <dt>21.Doctype作用? 严格模式与混杂模式如何区分?它们有何意义?</dt>
            <dd>
                <p>1. 声明位于文档中的最前面,处于 标签之前。告知浏览器的解析器,用什么文档类型 规范来解析这个文档。</p>
                <p>2. 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</p>
                <p>3. 在混杂模式中,页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止 站点无法工作。</p>
                <p>4. DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p>
            </dd>
        </li>
        <li>
            <dt>22.HTML5有哪些新特性?如何处理HTML5新标签的浏览器兼容问题?如何区分 HTML 和 HTML5?</dt>
            <dd>
                HTML5 现在已经不是 SGML 的子集,主要是关于图像,位置,存储,多任务等功能的 增加。 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长 期存储数据,浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动 删除 语意化更好的内容元素,比如 article、footer、header、nav、section 表单 控件,calendar、date、time、email、url、search 新的技术webworker, websockt, Geolocation
            </dd>
        </li>
        <li>
            <dt>23.iframe有那些缺点?</dt>
            <dd>
                iframe会阻塞主页面的Onload事件; iframe和主页面共享连接池,而浏览器对相同域的连接有限制,所以会影响页面的并行 加载。使用iframe之前需要考虑这两个缺点。如果需要使用iframe,最好是通过 javascript动态给iframe添加src属性值,这样可以可以绕开以上两个问题。
            </dd>
        </li>
        <li>
            <dt>24.请描述一下 cookies,sessionStorage 和 localStorage 的区别?</dt>
            <dd>
                <p>cookie在浏览器和服务器间来回传递。sessionStorage和localStorage不会;</p>
                <p>sessionStorage和localStorage的存储空间更大;</p>
                <p>sessionStorage和localStorage有 更多丰富易用的接口;</p>
                <p>sessionStorage和localStorage各自独立的存储空间。</p>
            </dd>
        </li>
        <li>
            <dt>25.平时如何管理你的项目?</dt>
            <dd>
                先期团队必须确定好全局样式(globe.css),编码模式(utf-8) 等 编写习惯必须一致(例如都是采用继承式的写法,单样式都写成一行); 标注样式编写人,各模块都及时标注(标注关键样式调用的地方); 页面进行标注(例如 页面 模块 开始和结束); CSS跟HTML 分文件夹并行存放,命名都得统一(例如style.css) JS 分文件夹存放 命民以该JS 功能为准英文翻译; 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理。
            </dd>
        </li>
        <li>
            <dt>26.你有哪些性能优化的方法?</dt>
            <dd>
                <p>看雅虎性能优化原则:
                <p>1. 减少http请求次数:CSS Sprites, JS、CSS源码压缩、图片大小控制合适;网页 Gzip,CDN托管,data缓存 ,图片服务器。</p>
                <p>2. 前端模板 JS+数据,减少由于HTML标签导致的带宽浪费,前端用变量保存AJAX请 求结果,每次操作本地变量,不用请求,减少请求次数</p>
                <p>3. 用innerHTML代替DOM操作,减少DOM操作次数,优化javascript性能。</p>
                <p>4. 当需要设置的样式很多时设置className而不是直接操作style。</p>
                <p>5. 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p>
                <p>6. 避免使用CSS Expression(css表达式)又称Dynamic properties(动态属性)。</p>
                <p>7. 图片预加载,将样式表放在顶部,将脚本放在底部 加上时间戳。</p>
                <p>8. 避免在页面的主体布局中使用table,table要等其中的内容完全下载之后才会显示出 来,显示比div+css布局慢。</p>
            </dd>
        </li>
        <li>
            <dt>27.清除浮动的几种方式,各自的优缺点</dt>
            <dd>
                <p>1.使用空标签清除浮动 clear:both(理论上能清楚任何标签,增加无意义的标签)</p>
                <p>2. 使用overflow:auto(空标签元素清除浮动而不得不增加无意代码的弊端,,使用 zoom:1 用于兼容IE)</p>
                <p>3. 是用afert伪元素清除浮动(用于非IE浏览器)</p>
            </dd>
        </li>
        <li>
            <dt>28.对WEB标准以及W3C的理解与认识?</dt>
            <dd>
                标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和js脚本、结 构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被 更广泛的设备所访问、更少的代码和组件,容易维护、改版方便,不需要变动页面内容、 提供打印版本而不需要复制内容、提高网站易用性。
            </dd>
        </li>
        <li>
            <dt>29.Yeoman具有哪些的特性</dt>
            <dd>
                <p>快如闪电的脚手架：使用可自定义的模板（如HTML5 Boilerplate, Bootstrap），RequireJS等轻松的创建新项目。</p>
                <p>非常棒的构建流程：不仅仅是工作被简化，yeoman同时也会优化图片文件，HTML文件，以及编译CoffeeScript和Compass文件。如果你使用AMD，将会通过r.js传递这些模块，大大简化工作。</p>
                <p>自动编译CoffeeScript和Compass：LiveReload将会监听文件变化并自动编译且刷新浏览器而不需要每次手动进行。</p>
                <p>自动检查你的脚本：你的所有脚本都会基于JSHint自动运行，以确保遵循语言的最佳规范。</p>
                <p>内建预览服务器：你不需要启动自己的HTTP服务器。用内置的一条命令即可解决。</p>
                <p>非常棒的图像优化：所有图片都使用OptiPNG和JPEGTran进行优化，使你的用户花费更少的时间来下载资源，有更多的时间使用你的应用程序。</p>
                <p>杀手级的包管理工具：需要一个依赖？只需要一个按键即可，yeoman允许你轻松地通过命令行(例如” bower serach jquery”)寻找最新的包来进行安装和更新而不需要打开浏览器。</p>
                <p>PhantomJS单元测试：yeoman通过PhantomJS轻松的进行单元测试。当你创建一个新的项目，它会自动帮你创建测试框架。</p>
            </dd>
        </li>
        <li>
            <dt>30.对restify应用框架的理解</dt>
            <dd>
                restify是一个基于Nodejs的REST应用框架，支持服务器端和客户端。restify比起express更专注于REST服务，去掉了express中的template, render等功能，同时强化了REST协议使用，版本化支持，HTTP的异常处理。
            </dd>
        </li>
        <li>
            <dt>31.Gulp和Grunt的异同点</dt>
            <dd>
                <p>相同点：</p>
                <p>易于使用：采用代码优于配置策略，Gulp让简单的事情继续简单，复杂的任务变得可管理。</p>
                <p>高效：通过利用Node.js强大的流，不需要往磁盘写中间文件，可以更快地完成构建。</p>
                <p>高质量：Gulp严格的插件指导方针，确保插件简单并且按你期望的方式工作。</p>
                <p>易于学习：通过把API降到最少，你能在很短的时间内学会Gulp。构建工作就像你设想的一样：是一系列流管道。</p>
                <p>不同点：</p>
                <p>易用 Gulp相比Grunt更简洁，而且遵循代码优于配置策略，维护Gulp更像是写代码。</p>
                <p>高效 Gulp相比Grunt更有设计感，核心设计基于Unix流的概念，通过管道连接，不需要写中间文件。</p>
                <p>高质量 Gulp的每个插件只完成一个功能，这也是Unix的设计原则之一，各个功能通过流进行整合并完成复杂的任务。例如：Grunt的imagemin插件不仅压缩图片，同时还包括缓存功能。他表示，在Gulp中，缓存是另一个插件，可以被别的插件使用，这样就促进了插件的可重用性。目前官方列出的有673个插件。</p>
                <p>易学 Gulp的核心API只有5个，掌握了5个API就学会了Gulp，之后便可以通过管道流组合自己想要的任务。</p>
            </dd>
        </li>
        <li>
            <dt>32.对YSlow的理解</dt>
            <dd>
                YSlow分析web页面并基于一种高性能网站的规则集对于提高网站页面性能提出建议。YSlow是基于firefox  的页面开发工具。YSlow基于预先制定的3组规则集或者用户自定义的规则集对页面进行分级。它提供一些提高网站页面性能的建议，分析页面的组成部分，显示页面静态文件，以及提供一些性能分析工具，包括Smush.it和JSLint
            </dd>
        </li>
        <li>
            <dt>33.JavaScript中的面向对象原理。</dt>
            <dd>
                JavaScript是一个基于原型的面向对象语言，每一个对象都有一个原型，Javascript的继承机制是通过模拟Java来实现的，并非真正严格意义上的继承，被继承的对象（Java中称为父类或超类）称为继承对象的原型，JavaScript中的所有的对象（包括自定义的对象）都有原型，没有指定原型的对象其原型默认为Object，Object是所有对象原型的根，Object中有prototype、constructor两个属性及hasOwnproperty（property）、isprototypeOf（Object）toString（），valueOf（）等方法函数，这就意味着所有的对象（包括自定义的对象）都有这些属性及方法。
            </dd>
        </li>
        <li>
            <dt>34.JavaScript中对象空间的创建与回收</dt>
            <dd>
                JavaScript中的对象同样可以用new调用构造函数来创建对象，（与Java相同构造函数在调用时立即产生对象并调用超类构造附加超类对象扩充内存，再自我初始化，最后执行本类构造体中的代码。）JavaScript在继承时的Call、apply的调用必须放在子对象构造器中的开头（就像Java中super（params）的调用必须放在子类构造器的第一条语句一样）否则在Call及apply之前的代码将会被重置（Java的编译器则明确限制了不能这样使用，否则将报checked异常），另外JavaScript的解释器（通常是浏览器）提供了对象的垃圾回收机制可以完成内存回收（Java的垃圾回收由Java虚拟机（通过Java的运行时环境来实现）启动垃圾回收线程来实现，因为Java是通过JVM的不跨平台实现Java的跨平台，所以Java可以再任何平台下运行而JavaScript则只能在解释器（通常是浏览器）下运行，他是一种解释性的语言所以JavaScript的内存回收只能由解释器来完成，需要区别的是C++中的对象内存回收是通过专门的析构函数调用delete（）方法来实现的，它的内存回收机制与Java及JavaScript都不相同）
            </dd>
        </li>
        <li>
            <dt>35.JavaScript中对象的创建方式</dt>
            <dd>
                <p>一、使用内置对象</p>
                <p>JavaScript可用的内置对象可分为两种：</p>
                <p>1，JavaScript语言原生对象（语言级对象），如String、Object、Function等；</p>
                <p>2，JavaScript运行期的宿主对象（环境宿主级对象），如window、document、body等。</p>
                <p>我们所说的使用内置对象，是指通过JavaScript语言原生对象的构造方法，实例化出一个新的对象。</p>
                <p>二、使用JSON符号</p>
                <p>JSON实际上充当了一种在JavaScript对象和字符串之间实现相互转换的协议。由于JSON的“外表”可以看成但村的字符串，因此JSON在</p>
                <p>JavaScript的对象传输方面可以起到一定的作用。例如把对象strObject转换成字符串后进行传输，在达到目的地后通过eval方法将其还原
                成对象</p>
                <p>三、自定义对象构造</p>
                <p>创建高级对象构造有两种方式：使用“this”关键字构造、使用原型prototype构造。</p>
            </dd>
        </li>
        <li>
            <dt>36.xhtml和html有什么区别</dt>
            <dd>
                <p>HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言</p>
                <p>最主要的不同：</p>
                <p>XHTML 元素必须被正确地嵌套。</p>
                <p>XHTML 元素必须被关闭。</p>
                <p>标签名必须用小写字母。</p>
                <p>XHTML 文档必须拥有根元素。</p>
            </dd>
        </li>
        <li>
            <dt>37.XMLHTTPRequest对象是什么？</dt>
            <dd>
                <p>最通用的定义为：XmlHttp是一套可以在Javascript、VbScript、Jscript等脚本语言中通过http协议传送或从接收XML及其他数据的一套API。XmlHttp最大的用处是可以更新网页的部分内容而不需要刷新整个页面。（这个功能正是AJAX的一大特点之一）</p>
                <p>来自MSDN的解释：XmlHttp提供客户端同http服务器通讯的协议。客户端可以通过XmlHttp对象(MSXML2.XMLHTTP.3.0)向http服务器发送请求并使用微软XML文档对象模型Microsoft? XML Document Object Model (DOM)处理回应。</p>
            </dd>
        </li>
        <li>
            <dt>38.为什么要初始化CSS样式?</dt>
            <dd>
                <p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>
                <p>– 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>
                <p>*最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议）</p>
            </dd>
        </li>
        <li>
            <dt>39.谈谈This对象的理解</dt>
            <dd>
                <p>this是js的一个关键字，随着函数使用场合不同，this的值会发生变化。</p>
                <p>但是有一个总原则，那就是this指的是调用函数的那个对象。</p>
                <p>this一般情况下：是全局对象Global。 作为方法调用，那么this就是指这个对象</p>
            </dd>
        </li>
        <li>
            <dt>40.事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</dt>
            <dd>
                <p>1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</p>
                <p>2. 事件处理机制：IE是事件冒泡、火狐是 事件捕获；</p>
                <p>3. ev.stopPropagation();</p>

            </dd>
        </li>
        <li>
            <dt>41.Jquery与jQuery UI 有啥区别？</dt>
            <dd>
                <p>*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。</p>
                <p>*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。</p>
                <p>提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</p>
            </dd>
        </li>
        <li>
            <dt>42.针对 jQuery 的优化方法？</dt>
            <dd>
                <p>*基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。</p>
                <p>*频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。</p>
                <p>比如：var str=$("a").attr("href"); *for (var i = size; i < arr.length; i++) {}</p>
                <p>for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：</p>
                <p>for (var i = size, length = arr.length; i < length; i++) {}</p>
            </dd>
        </li>
        <li>
            <dt>43.页面重构怎么操作？</dt>
            <dd>
                <p>页面重构就是根据原有页面内容和结构的基础上，通过div+css写出符合web标准的页面结构。</p>
                <p>具体实现要达到以下三点：</p>
                <p>1. 结构完整，可通过标准验证</p>
                <p>2. 标签语义化，结构合理</p>
                <p>3. 充分考虑到页面在站点中的“作用和重要性”，并对其进行有针对性的优化</p>
            </dd>
        </li>
        <li>
            <dt>44.什么叫优雅降级和渐进增强？</dt>
            <dd>
                <p>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
                <p>优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
                <p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p>
            </dd>
        </li>
        <li>
            <dt>45.WEB应用从服务器主动推送Data到客户端有那些方式？</dt>
            <dd>
                <p>1. html5 websoket</p>
                <p>2. WebSocket 通过 Flash</p>
                <p>3. XHR长时间连接</p>
                <p>4. XHR Multipart Streaming</p>
                <p>5. 不可见的Iframe</p>
                <p>6. script标签的长时间连接(可跨域)</p>
            </dd>
        </li>
        <li>
            <dt>46.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</dt>
            <dd>
                <p>查找浏览器缓存</p>
                <p>DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求</p>
                <p>进行HTTP协议会话</p>
                <p>客户端发送报头(请求报头)</p>
                <p>服务器回馈报头(响应报头)</p>
                <p>html文档开始下载</p>
                <p>文档树建立，根据标记请求所需指定MIME类型的文件</p>
                <p>文件显示</p>
                <p>{浏览器这边做的工作大致分为以下几步：</p>
                <p>加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。</p>
                <p>解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等等）}</p>
            </dd>
        </li>
        <li>
            <dt>47.如何设计突发大规模并发架构？</dt>
            <dd>
                <p>清晰的视觉纵线、信息的分组、极致的减法、</p>
                <p>利用选择代替输入、标签及文字的排布方式、</p>
                <p>依靠明文确认密码、合理的键盘利用、</p>
            </dd>
        </li>
        <li>
            <dt>48.如何判断当前脚本运行在浏览器还是node环境中？</dt>
            <dd>
                通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中
            </dd>
        </li>
        <li>
            <dt>49.如何编写高性能的Javascript？</dt>
            <dd>
                垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
            </dd>
        </li>
        <li>
            <dt>50.那些操作会造成内存泄漏？</dt>
            <dd>
                内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
            </dd>
        </li>
        <li>
            <dt>51.异步加载的方式有哪些？</dt>
            <dd>
                <p>(1) defer，只支持IE</p>
                <p>(2) async：</p>
                <p>(3) 创建script，插入到DOM中，加载完毕后callBack</p>
            </dd>
        </li>

    </ul>
</div>
</body>
</html>